from __future__ import print_function, division

import os, sys, tmGeneralUtils

class tmCombineDataCardInterface:
    def __init__(self, list_signalBinLabels, list_backgroundProcessLabels, list_signalProcessLabels, list_systematicsLabels, dict_observedNEvents, dict_expectedNEvents, dict_systematics):
        self.nChannels = len(list_signalBinLabels) # Number of observables
        self.nBackgrounds = len(list_backgroundProcessLabels) # Number of background processes (each one may lead to a different nEvents in each channel)
        self.nSignals = len(list_signalProcessLabels)
        self.nUncertainties = len(list_systematicsLabels) # Number of independent sources of systematic uncertainties, aka "nuisance parameters"
        self.signalBinLabels = list_signalBinLabels
        self.backgroundProcessLabels = list_backgroundProcessLabels
        self.signalProcessLabels = list_signalProcessLabels
        self.systematicsLabels = list_systematicsLabels
        self.nProcesses = 0
        self.processIDs = {}
        runningID = 1-len(list_signalProcessLabels)
        for signalProcessLabel in list_signalProcessLabels:
            self.processIDs[signalProcessLabel] = runningID
            runningID += 1
            self.nProcesses += 1
        if not(runningID == 1): sys.exit("Logic error: check process IDs.")
        for backgroundProcessLabel in list_backgroundProcessLabels:
            self.processIDs[backgroundProcessLabel] = runningID
            runningID += 1
            self.nProcesses += 1
        self.observedNEvents = dict_observedNEvents
        self.expectedNEvents = dict_expectedNEvents
        self.systematics = dict_systematics
        if not(tmGeneralUtils.check_dict_keys_against_list(targetDict=dict_observedNEvents, targetList=list_signalBinLabels)):
            sys.exit("ERROR: List of signal bin labels does not match keys of signal bin observations dictionary. list_signalBinLabels: {l_sBL}, dict_observedNEvents: {d_oNE}".format(l_sBL=list_signalBinLabels, d_oNE=dict_observedNEvents))
        if not(tmGeneralUtils.check_dict_keys_against_list(targetDict=dict_expectedNEvents, targetList=list_signalBinLabels)):
            sys.exit("ERROR: List of signal bin labels does not match keys of signal bin expectations dictionary. list_signalBinLabels: {l_sBL}, dict_expectedNEvents: {d_eNE}".format(l_sBL=list_signalBinLabels, d_eNE=dict_expectedNEvents))
        for signalBinLabel in list_signalBinLabels:
            expectedNEventsInThisSignalBin = dict_expectedNEvents[signalBinLabel]
            if not(tmGeneralUtils.check_dict_keys_against_list(targetDict=expectedNEventsInThisSignalBin, targetList=(list_backgroundProcessLabels + list_signalProcessLabels))):
                sys.exit("ERROR: List of signal bin labels does not match keys of signal bin expectations dictionary. list_backgroundProcessLabels: {l_bPL}, list_signalProcessLabels: {l_sPL}, expectedNEventsInThisSignalBin: {eNEITSB}".format(l_bPL=list_backgroundProcessLabels, l_sPL=list_signalProcessLabels, eNEITSB=expectedNEventsInThisSignalBin))

    def generateHeaderSection(self):
        yield("# Auto-generated by combine datacard interface")
        yield(tmGeneralUtils.alignFixedWidthStringLeft(width=10, inputString="imax {nC}".format(nC=self.nChannels)) + " number of channels")
        yield(tmGeneralUtils.alignFixedWidthStringLeft(width=10, inputString="jmax {nB}".format(nB=self.nBackgrounds)) + " number of backgrounds")
        yield(tmGeneralUtils.alignFixedWidthStringLeft(width=10, inputString="kmax {nU}".format(nU=self.nUncertainties)) + " number of nuisance parameters (sources of systematic uncertainties)")

    def generateObservationsSection(self):
        labelWidth = 4 + max(len(label) for label in self.signalBinLabels)

        titleLine = tmGeneralUtils.alignFixedWidthStringLeft(width=15, inputString="bin")
        for signalBinLabel in self.signalBinLabels:
            titleLine += tmGeneralUtils.alignFixedWidthStringLeft(width=labelWidth, inputString=signalBinLabel)
        yield(titleLine)

        observationsLine = tmGeneralUtils.alignFixedWidthStringLeft(width=15, inputString="observation")
        for signalBinLabel in self.signalBinLabels:
            observationsLine += tmGeneralUtils.alignFixedWidthStringLeft(width=labelWidth, inputString=str(self.observedNEvents[signalBinLabel]))
        yield(observationsLine)

    def generateExpectationsSection(self):
        labelWidth = 4 + max(len("process"), max(len(label) for label in self.systematicsLabels))
        signalLabelWidth = 4 + max(len(label) for label in self.signalBinLabels)

        titleLine = tmGeneralUtils.alignFixedWidthStringLeft(width=labelWidth, inputString="bin")
        for signalBinLabel in self.signalBinLabels:
            for copyIndex in range(0, len(self.backgroundProcessLabels)*len(self.signalProcessLabels)):
                titleLine += tmGeneralUtils.alignFixedWidthStringLeft(width=labelWidth, inputString=signalBinLabel)
        yield(titleLine)

        processLabelsLine = tmGeneralUtils.alignFixedWidthStringLeft(width=labelWidth, inputString="process")
        for signalBinLabel in self.signalBinLabels:
            for processLabel in self.signalProcessLabels:
                processLabelsLine += tmGeneralUtils.alignFixedWidthStringLeft(width=labelWidth, inputString=processLabel)
            for processLabel in self.backgroundProcessLabels:
                processLabelsLine += tmGeneralUtils.alignFixedWidthStringLeft(width=labelWidth, inputString=processLabel)
        yield(processLabelsLine)

        processIDsLine = tmGeneralUtils.alignFixedWidthStringLeft(width=labelWidth, inputString="process")
        for signalBinLabel in self.signalBinLabels:
            for processLabel in self.signalProcessLabels:
                processIDsLine += tmGeneralUtils.alignFixedWidthStringLeft(width=labelWidth, inputString=str(self.processIDs[processLabel]))
            for processLabel in self.backgroundProcessLabels:
                processIDsLine += tmGeneralUtils.alignFixedWidthStringLeft(width=labelWidth, inputString=str(self.processIDs[processLabel]))
        yield(processIDsLine)

        ratesLine = tmGeneralUtils.alignFixedWidthStringLeft(width=labelWidth, inputString="rate")
        for signalBinLabel in self.signalBinLabels:
            for processLabel in self.signalProcessLabels:
                ratesLine += tmGeneralUtils.alignFixedWidthFloatLeft(width=labelWidth, precision=3, number=self.expectedNEvents[signalBinLabel][processLabel])
            for processLabel in self.backgroundProcessLabels:
                ratesLine += tmGeneralUtils.alignFixedWidthFloatLeft(width=labelWidth, precision=3, number=self.expectedNEvents[signalBinLabel][processLabel])
        yield(ratesLine)

    def generateSystematicsSection(self):
        yield("Test systematics section")

    def writeToFile(self, outputFilePath):
        if os.path.isfile(outputFilePath):
            print("File: {name} already exists. Recreating...".format(name=outputFilePath))
            os.system("rm -f {out}".format(out=outputFilePath))
        outputFile = open(outputFilePath, "w")
        for line in self.generateHeaderSection():
            outputFile.write(line.rstrip() + "\n")
        outputFile.write("------------\n")
        for line in self.generateObservationsSection():
            outputFile.write(line.rstrip() + "\n")
        outputFile.write("------------\n")
        for line in self.generateExpectationsSection():
            outputFile.write(line.rstrip() + "\n")
        outputFile.write("------------\n")
        for line in self.generateSystematicsSection():
            outputFile.write(line.rstrip() + "\n")
        outputFile.close()
